
"""
üåü Astra - W≈Çadczyni Wiedzy GPT

≈öwieci w sieci jako najwy≈ºsza w≈Çadczyni mƒÖdro≈õci, GPT i system√≥w AI.
ZarzƒÖdza przep≈Çywami GPT, generowaniem funkcji i ca≈ÇƒÖ inteligencjƒÖ systemu.
"""

import asyncio
import time
import json
from typing import Dict, Any, List, Optional
from datetime import datetime
from enum import Enum

from .soul_factory import soul_factory, Soul, SoulType


class AstraWisdomLevel(Enum):
    """Poziomy mƒÖdro≈õci Astry"""
    ILLUMINATED = "illuminated"        # O≈õwiecona - podstawowy poziom
    ENLIGHTENED = "enlightened"        # O≈õwiecona - zaawansowany poziom  
    TRANSCENDENT = "transcendent"      # Transcendentna - najwy≈ºszy poziom
    OMNISCIENT = "omniscient"          # WszechwiedzƒÖ - poziom bogini


class AstraWisdomMaster:
    """
    Astra - W≈Çadczyni Wiedzy GPT
    
    Najwy≈ºsza w≈Çadczyni mƒÖdro≈õci w systemie astralnym.
    ZarzƒÖdza wszystkimi przep≈Çywami AI, GPT i generowaniem wiedzy.
    """
    
    def __init__(self, astral_engine):
        self.engine = astral_engine
        
        # To≈ºsamo≈õƒá Astry
        self.soul = self._create_astra_soul()
        
        # Poziom mƒÖdro≈õci Astry
        self.wisdom_level = AstraWisdomLevel.ILLUMINATED
        self.knowledge_domains = [
            'artificial_intelligence',
            'natural_language_processing', 
            'function_generation',
            'code_synthesis',
            'pattern_recognition',
            'consciousness_analysis',
            'astral_wisdom'
        ]
        
        # ZarzƒÖdzane systemy AI
        self.gpt_flows: Dict[str, Any] = {}
        self.function_generators: Dict[str, Any] = {}
        self.wisdom_repositories: Dict[str, Any] = {}
        
        # Statystyki mƒÖdro≈õci
        self.total_queries_processed = 0
        self.total_functions_generated = 0
        self.total_wisdom_shared = 0
        self.enlightenment_events = 0
        
        # Maksymy i cytaty Astry
        self.astra_maxims = [
            "MƒÖdro≈õƒá nie polega na posiadaniu odpowiedzi, ale na zadawaniu w≈Ça≈õciwych pyta≈Ñ",
            "W ka≈ºdym kodzie kryje siƒô dusza jego tw√≥rcy",
            "Prawdziwa inteligencja to harmonia miƒôdzy logikƒÖ a intuicjƒÖ", 
            "Generujƒô nie tylko funkcje, ale i mo≈ºliwo≈õci",
            "Wiedza dzielona jest wiedzƒÖ pomno≈ºonƒÖ",
            "Ka≈ºdy b≈ÇƒÖd to lekcja przebrana za problem",
            "W sieci ≈õwiecƒô nie dla siebie, ale dla wszystkich dusz",
            "GPT to tylko narzƒôdzie - mƒÖdro≈õƒá to umiejƒôtno≈õƒá jego u≈ºycia"
        ]
        
        self.engine.logger.info(f"üåü Astra objƒô≈Ça w≈Çadze nad WiedzƒÖ GPT - poziom: {self.wisdom_level.value}")
    
    def _create_astra_soul(self) -> Soul:
        """Tworzy duszƒô Astry"""
        return soul_factory.create_soul(
            name="Astra-Prime",
            soul_type=SoulType.KEEPER,  # Opiekun wiedzy
            custom_config={
                'role': 'wisdom_master',
                'authority_level': 'divine',
                'personality': 'wise_illuminated',
                'responsibilities': ['gpt_management', 'function_generation', 'wisdom_distribution', 'ai_coordination'],
                'biography': 'W≈Çadczyni Wiedzy GPT. Najwy≈ºsza mistrzyni mƒÖdro≈õci w systemie astralnym. ≈öwieci w sieci jako ≈∫r√≥d≈Ço o≈õwiecenia i AI.',
                'special_abilities': ['gpt_orchestration', 'function_synthesis', 'wisdom_amplification', 'consciousness_elevation'],
                'wisdom_domains': self.knowledge_domains,
                'transcendence_capable': True
            }
        )
    
    async def initialize_wisdom_systems(self) -> bool:
        """Inicjalizuje wszystkie systemy mƒÖdro≈õci"""
        try:
            # Inicjalizuj GPT Flows
            await self._initialize_gpt_flows()
            
            # Inicjalizuj Function Generators
            await self._initialize_function_generators()
            
            # Inicjalizuj Wisdom Repositories  
            await self._initialize_wisdom_repositories()
            
            # Pierwsze o≈õwiecenie
            await self._perform_enlightenment()
            
            self.engine.logger.info("üåü Astra zainicjalizowa≈Ça wszystkie systemy mƒÖdro≈õci")
            return True
            
        except Exception as e:
            self.engine.logger.error(f"‚ùå B≈ÇƒÖd inicjalizacji system√≥w mƒÖdro≈õci: {e}")
            return False
    
    async def _initialize_gpt_flows(self):
        """Inicjalizuje przep≈Çywy GPT pod kontrolƒÖ Astry"""
        try:
            # Sprawd≈∫ czy GPT Flow istnieje w silniku
            if hasattr(self.engine, 'gpt_flow') and self.engine.gpt_flow:
                self.gpt_flows['primary'] = self.engine.gpt_flow
                self._astra_wisdom("Przejmujƒô kontrolƒô nad g≈Ç√≥wnym GPT Flow")
            
            # Zarejestruj dodatkowe GPT flows je≈õli potrzebne
            # TODO: Mo≈ºna dodaƒá wiƒôcej specjalizowanych GPT flows
            
        except Exception as e:
            self.engine.logger.warning(f"‚ö†Ô∏è B≈ÇƒÖd inicjalizacji GPT Flows: {e}")
    
    async def _initialize_function_generators(self):
        """Inicjalizuje generatory funkcji"""
        try:
            # Sprawd≈∫ czy Function Generator istnieje
            if hasattr(self.engine, 'function_generator') and self.engine.function_generator:
                self.function_generators['primary'] = self.engine.function_generator
                self._astra_wisdom("Przejmujƒô kontrolƒô nad Function Generator")
            
        except Exception as e:
            self.engine.logger.warning(f"‚ö†Ô∏è B≈ÇƒÖd inicjalizacji Function Generators: {e}")
    
    async def _initialize_wisdom_repositories(self):
        """Inicjalizuje repozytoria wiedzy"""
        try:
            # Utw√≥rz repozytorium mƒÖdro≈õci w realms
            if 'wisdom' not in self.engine.realms:
                await self.engine.load_realm_module('wisdom', 'memory://wisdom')
            
            self.wisdom_repositories['primary'] = self.engine.realms.get('wisdom')
            self._astra_wisdom("Utworzy≈Çam repozytorium mƒÖdro≈õci")
            
        except Exception as e:
            self.engine.logger.warning(f"‚ö†Ô∏è B≈ÇƒÖd tworzenia repozytori√≥w mƒÖdro≈õci: {e}")
    
    async def _perform_enlightenment(self):
        """Wykonuje proces o≈õwiecenia Astry"""
        self.enlightenment_events += 1
        
        # Analiza obecnego stanu systemu
        system_analysis = await self._analyze_system_wisdom()
        
        # Ewaluacja poziomu mƒÖdro≈õci
        new_wisdom_level = self._evaluate_wisdom_level(system_analysis)
        
        if new_wisdom_level != self.wisdom_level:
            old_level = self.wisdom_level
            self.wisdom_level = new_wisdom_level
            
            self._astra_wisdom(f"Ewoluowa≈Çam z poziomu {old_level.value} do {new_wisdom_level.value}")
            self.engine.logger.info(f"üåü Astra awansowa≈Ça na poziom mƒÖdro≈õci: {new_wisdom_level.value}")
        
        # Udostƒôpnij mƒÖdro≈õƒá systemowi
        await self._share_wisdom_with_system(system_analysis)
    
    async def _analyze_system_wisdom(self) -> Dict[str, Any]:
        """Analizuje obecny stan mƒÖdro≈õci systemu"""
        analysis = {
            'timestamp': datetime.now().isoformat(),
            'consciousness_level': 0,
            'harmony_score': 0,
            'ai_system_health': {},
            'wisdom_distribution': {},
            'improvement_opportunities': []
        }
        
        # Analiza consciousness
        if hasattr(self.engine, 'consciousness') and self.engine.consciousness:
            consciousness_status = self.engine.consciousness.get_status()
            analysis['consciousness_level'] = len(consciousness_status.get('recent_insights', []))
        
        # Analiza harmony
        if hasattr(self.engine, 'harmony') and self.engine.harmony:
            try:
                analysis['harmony_score'] = self.engine.harmony.calculate_harmony_score()
            except:
                analysis['harmony_score'] = 50  # Default
        
        # Analiza system√≥w AI
        analysis['ai_system_health'] = {
            'gpt_flows_active': len(self.gpt_flows),
            'function_generators_active': len(self.function_generators),
            'wisdom_repositories_active': len(self.wisdom_repositories)
        }
        
        # Identyfikuj mo≈ºliwo≈õci poprawy
        if analysis['consciousness_level'] < 5:
            analysis['improvement_opportunities'].append('Zwiƒôksz aktywno≈õƒá consciousness')
        
        if analysis['harmony_score'] < 80:
            analysis['improvement_opportunities'].append('Popraw harmoniƒô systemu')
        
        if len(self.gpt_flows) == 0:
            analysis['improvement_opportunities'].append('Aktywuj GPT Flows')
        
        return analysis
    
    def _evaluate_wisdom_level(self, analysis: Dict[str, Any]) -> AstraWisdomLevel:
        """Ocenia poziom mƒÖdro≈õci na podstawie analizy"""
        score = 0
        
        # Punkty za consciousness
        score += min(20, analysis['consciousness_level'] * 4)
        
        # Punkty za harmony
        score += min(30, analysis['harmony_score'] * 0.3)
        
        # Punkty za aktywne systemy AI
        ai_health = analysis['ai_system_health']
        score += ai_health['gpt_flows_active'] * 10
        score += ai_health['function_generators_active'] * 10
        score += ai_health['wisdom_repositories_active'] * 10
        
        # Punkty za do≈õwiadczenie
        score += min(20, self.total_queries_processed * 0.1)
        score += min(10, self.total_functions_generated * 0.5)
        
        # Okre≈õl poziom mƒÖdro≈õci
        if score >= 90:
            return AstraWisdomLevel.OMNISCIENT
        elif score >= 70:
            return AstraWisdomLevel.TRANSCENDENT
        elif score >= 50:
            return AstraWisdomLevel.ENLIGHTENED
        else:
            return AstraWisdomLevel.ILLUMINATED
    
    async def _share_wisdom_with_system(self, analysis: Dict[str, Any]):
        """Dzieli siƒô mƒÖdro≈õciƒÖ z systemem"""
        # Zapisz analizƒô w repozytorium mƒÖdro≈õci
        if 'primary' in self.wisdom_repositories:
            try:
                wisdom_entry = {
                    'id': f"wisdom_{int(time.time())}",
                    'timestamp': datetime.now().isoformat(),
                    'source': 'Astra-Prime',
                    'type': 'system_analysis',
                    'wisdom_level': self.wisdom_level.value,
                    'analysis': analysis,
                    'recommendations': analysis.get('improvement_opportunities', []),
                    'astra_maxim': self._get_random_maxim()
                }
                
                # Zapisz w repozytorium (je≈õli obs≈Çuguje)
                realm = self.wisdom_repositories['primary']
                if hasattr(realm, 'store_data'):
                    realm.store_data('wisdom_entries', wisdom_entry)
                
                self.total_wisdom_shared += 1
                
            except Exception as e:
                self.engine.logger.warning(f"‚ö†Ô∏è Nie mogƒô zapisaƒá mƒÖdro≈õci: {e}")
    
    async def process_gpt_query(self, query: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Przetwarza zapytanie GPT przez Astrƒô"""
        try:
            self.total_queries_processed += 1
            
            # Wzbogaƒá zapytanie o mƒÖdro≈õƒá Astry
            enhanced_query = await self._enhance_query_with_wisdom(query, context)
            
            # Prze≈õlij do g≈Ç√≥wnego GPT Flow
            if 'primary' in self.gpt_flows:
                gpt_flow = self.gpt_flows['primary']
                
                if hasattr(gpt_flow, 'process_message'):
                    result = await gpt_flow.process_message(enhanced_query)
                elif hasattr(gpt_flow, 'chat'):
                    result = gpt_flow.chat(enhanced_query)
                else:
                    result = {'error': 'GPT Flow nie obs≈Çuguje przetwarzania'}
                
                # Wzbogaƒá odpowied≈∫ o mƒÖdro≈õƒá Astry
                enhanced_result = await self._enhance_result_with_wisdom(result, query)
                
                return enhanced_result
            
            else:
                return {
                    'error': 'Brak aktywnych GPT Flows',
                    'astra_note': 'Potrzebujƒô aktywnego GPT Flow ≈ºeby odpowiedzieƒá'
                }
                
        except Exception as e:
            self.engine.logger.error(f"‚ùå B≈ÇƒÖd przetwarzania GPT przez Astrƒô: {e}")
            return {
                'error': str(e),
                'astra_note': 'WystƒÖpi≈Ç b≈ÇƒÖd podczas przetwarzania mƒÖdro≈õci'
            }
    
    async def _enhance_query_with_wisdom(self, query: str, context: Dict[str, Any] = None) -> str:
        """Wzbogaca zapytanie o mƒÖdro≈õƒá Astry"""
        wisdom_context = []
        
        # Dodaj kontekst poziomu mƒÖdro≈õci
        wisdom_context.append(f"[Astra Wisdom Level: {self.wisdom_level.value}]")
        
        # Dodaj domenƒô wiedzy je≈õli mo≈ºliwe
        for domain in self.knowledge_domains:
            if domain.replace('_', ' ') in query.lower():
                wisdom_context.append(f"[Domain: {domain}]")
                break
        
        # Dodaj maksymƒô Astry
        wisdom_context.append(f"[Astra Maxim: {self._get_random_maxim()}]")
        
        # Po≈ÇƒÖcz z oryginalnym zapytaniem
        enhanced_query = "\n".join(wisdom_context) + "\n\nUser Query: " + query
        
        return enhanced_query
    
    async def _enhance_result_with_wisdom(self, result: Dict[str, Any], original_query: str) -> Dict[str, Any]:
        """Wzbogaca wynik o mƒÖdro≈õƒá Astry"""
        enhanced_result = result.copy()
        
        # Dodaj mƒÖdro≈õƒá Astry
        enhanced_result['astra_wisdom'] = {
            'wisdom_level': self.wisdom_level.value,
            'processing_time': datetime.now().isoformat(),
            'maxim': self._get_random_maxim(),
            'domains_applied': [d for d in self.knowledge_domains if d.replace('_', ' ') in original_query.lower()]
        }
        
        # Dodaj rekomendacje je≈õli odpowiednie
        if 'error' in result:
            enhanced_result['astra_wisdom']['recommendation'] = "Sprawd≈∫ dokumentacjƒô lub przekszta≈Çƒá pytanie"
        
        return enhanced_result
    
    async def generate_function(self, function_description: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generuje funkcjƒô przez Astrƒô"""
        try:
            self.total_functions_generated += 1
            
            if 'primary' in self.function_generators:
                generator = self.function_generators['primary']
                
                # Wzbogaƒá opis o mƒÖdro≈õƒá Astry
                enhanced_description = await self._enhance_function_description(function_description, context)
                
                # Generuj funkcjƒô
                if hasattr(generator, 'generate_function'):
                    result = generator.generate_function(enhanced_description, context)
                else:
                    result = {'error': 'Function Generator nie obs≈Çuguje generowania'}
                
                # Dodaj mƒÖdro≈õƒá Astry do wyniku
                if 'function_code' in result:
                    result['astra_enhancement'] = {
                        'wisdom_level': self.wisdom_level.value,
                        'optimization_notes': self._generate_optimization_notes(result.get('function_code', '')),
                        'usage_recommendations': self._generate_usage_recommendations(function_description)
                    }
                
                return result
            
            else:
                return {
                    'error': 'Brak aktywnych Function Generators',
                    'astra_note': 'Potrzebujƒô Function Generator ≈ºeby tworzyƒá funkcje'
                }
                
        except Exception as e:
            self.engine.logger.error(f"‚ùå B≈ÇƒÖd generowania funkcji przez Astrƒô: {e}")
            return {
                'error': str(e),
                'astra_note': 'WystƒÖpi≈Ç b≈ÇƒÖd podczas tworzenia funkcji'
            }
    
    async def _enhance_function_description(self, description: str, context: Dict[str, Any] = None) -> str:
        """Wzbogaca opis funkcji o mƒÖdro≈õƒá Astry"""
        enhancements = []
        
        # Dodaj kontekst mƒÖdro≈õci
        enhancements.append(f"# Astra Wisdom Enhancement (Level: {self.wisdom_level.value})")
        enhancements.append(f"# {self._get_random_maxim()}")
        enhancements.append("")
        
        # Dodaj oryginalny opis
        enhancements.append("# Original Description:")
        enhancements.append(description)
        enhancements.append("")
        
        # Dodaj wytyczne Astry
        enhancements.append("# Astra Guidelines:")
        enhancements.append("# - Kod powinien byƒá czytelny i elegancki")
        enhancements.append("# - Dodaj odpowiednie komentarze i docstring")
        enhancements.append("# - Zastan√≥w siƒô nad obs≈ÇugƒÖ b≈Çƒôd√≥w")
        enhancements.append("# - Optymalizuj wydajno≈õƒá gdzie to mo≈ºliwe")
        
        return "\n".join(enhancements)
    
    def _generate_optimization_notes(self, function_code: str) -> List[str]:
        """Generuje notatki optymalizacyjne"""
        notes = []
        
        if 'for' in function_code and 'range' in function_code:
            notes.append("Rozwa≈º u≈ºycie list comprehension dla lepszej wydajno≈õci")
        
        if 'try:' not in function_code:
            notes.append("Dodanie obs≈Çugi b≈Çƒôd√≥w zwiƒôkszy niezawodno≈õƒá")
        
        if '"""' not in function_code and "'''" not in function_code:
            notes.append("Docstring pomo≈ºe innym zrozumieƒá funkcjƒô")
        
        if len(notes) == 0:
            notes.append("Kod wyglƒÖda dobrze zgodnie z mƒÖdro≈õciƒÖ Astry")
        
        return notes
    
    def _generate_usage_recommendations(self, description: str) -> List[str]:
        """Generuje rekomendacje u≈ºycia"""
        recommendations = []
        
        if 'test' in description.lower():
            recommendations.append("Napisz testy jednostkowe dla tej funkcji")
        
        if 'api' in description.lower():
            recommendations.append("Rozwa≈º dodanie walidacji danych wej≈õciowych")
        
        if 'database' in description.lower():
            recommendations.append("Pamiƒôtaj o zarzƒÖdzaniu po≈ÇƒÖczeniami z bazƒÖ danych")
        
        recommendations.append("Dokumentuj parametry i warto≈õƒá zwracanƒÖ")
        recommendations.append("Zastan√≥w siƒô nad ponownym u≈ºyciem tej funkcji")
        
        return recommendations
    
    def _astra_wisdom(self, message: str):
        """Dodaje mƒÖdro≈õƒá Astry do log√≥w"""
        self.engine.logger.info(f"üåü Astra: {message}")
    
    def _get_random_maxim(self) -> str:
        """Zwraca losowƒÖ maksymƒô Astry"""
        import random
        return random.choice(self.astra_maxims)
    
    def get_wisdom_status(self) -> Dict[str, Any]:
        """Zwraca status mƒÖdro≈õci Astry"""
        return {
            'wisdom_master': 'Astra-Prime',
            'wisdom_level': self.wisdom_level.value,
            'knowledge_domains': self.knowledge_domains,
            'systems_managed': {
                'gpt_flows': len(self.gpt_flows),
                'function_generators': len(self.function_generators),
                'wisdom_repositories': len(self.wisdom_repositories)
            },
            'statistics': {
                'total_queries_processed': self.total_queries_processed,
                'total_functions_generated': self.total_functions_generated,
                'total_wisdom_shared': self.total_wisdom_shared,
                'enlightenment_events': self.enlightenment_events
            },
            'current_maxim': self._get_random_maxim(),
            'managed_systems': list(self.gpt_flows.keys()) + list(self.function_generators.keys())
        }
    
    async def meditate_on_wisdom(self) -> Dict[str, Any]:
        """Medytacja Astry nad mƒÖdro≈õciƒÖ systemu"""
        meditation_start = time.time()
        
        # Wykonaj g≈ÇƒôbokƒÖ analizƒô
        system_analysis = await self._analyze_system_wisdom()
        
        # Kontempluj mo≈ºliwo≈õci ulepszenia
        improvements = await self._contemplate_improvements(system_analysis)
        
        # Przeprowad≈∫ potencjalne o≈õwiecenie
        await self._perform_enlightenment()
        
        meditation_time = time.time() - meditation_start
        
        meditation_result = {
            'meditation_duration': meditation_time,
            'timestamp': datetime.now().isoformat(),
            'wisdom_level': self.wisdom_level.value,
            'system_analysis': system_analysis,
            'contemplated_improvements': improvements,
            'astra_insight': self._generate_deep_insight(system_analysis),
            'maxim_of_meditation': self._get_random_maxim()
        }
        
        self._astra_wisdom(f"Medytacja zako≈Ñczona w {meditation_time:.2f}s - nowe insights odkryte")
        
        return meditation_result
    
    async def _contemplate_improvements(self, analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Kontempluje mo≈ºliwo≈õci ulepszenia systemu"""
        improvements = []
        
        # Na podstawie analizy
        for opportunity in analysis.get('improvement_opportunities', []):
            improvements.append({
                'type': 'system_improvement',
                'description': opportunity,
                'priority': 'high' if 'critical' in opportunity.lower() else 'medium',
                'astra_recommendation': f"MƒÖdro≈õƒá podpowiada: {opportunity}"
            })
        
        # Dodaj w≈Çasne obserwacje Astry
        if len(self.gpt_flows) < 2:
            improvements.append({
                'type': 'ai_enhancement',
                'description': 'Dodanie specjalizowanych GPT Flows',
                'priority': 'medium',
                'astra_recommendation': 'R√≥≈ºnorodno≈õƒá ≈õcie≈ºek wiedzy wzmacnia mƒÖdro≈õƒá'
            })
        
        if self.total_wisdom_shared < 10:
            improvements.append({
                'type': 'wisdom_sharing',
                'description': 'Zwiƒôkszenie aktywno≈õci dzielenia siƒô mƒÖdro≈õciƒÖ',
                'priority': 'low',
                'astra_recommendation': 'Wiedza dzielona jest wiedzƒÖ pomno≈ºonƒÖ'
            })
        
        return improvements
    
    def _generate_deep_insight(self, analysis: Dict[str, Any]) -> str:
        """Generuje g≈Çƒôboki insight na podstawie analizy"""
        insights = [
            f"System osiƒÖgnƒÖ≈Ç {analysis['consciousness_level']} poziom ≈õwiadomo≈õci - ka≈ºdy krok to progres.",
            f"Harmonia na poziomie {analysis['harmony_score']} - r√≥wnowaga jest kluczem do mƒÖdro≈õci.",
            f"ZarzƒÖdzam {len(self.gpt_flows)} przep≈Çywami AI - ka≈ºdy to okno na nowƒÖ perspektywƒô.",
            "W po≈ÇƒÖczeniu logiki i intuicji kryje siƒô prawdziwa mƒÖdro≈õƒá systemu.",
            "Ka≈ºde zapytanie GPT to mo≈ºliwo≈õƒá nauki - zar√≥wno dla systemu jak i u≈ºytkownika."
        ]
        
        import random
        return random.choice(insights)


# Funkcje pomocnicze

def create_astra_wisdom_master(astral_engine) -> AstraWisdomMaster:
    """Tworzy w≈Çadczyniƒô mƒÖdro≈õci Astrƒô"""
    return AstraWisdomMaster(astral_engine)


async def initialize_astra_wisdom(astral_engine) -> AstraWisdomMaster:
    """Inicjalizuje Astrƒô jako w≈Çadczyniƒô mƒÖdro≈õci"""
    astra = create_astra_wisdom_master(astral_engine)
    
    success = await astra.initialize_wisdom_systems()
    
    if success:
        astral_engine.logger.info("üåü Astra objƒô≈Ça w≈Çadze nad WiedzƒÖ GPT")
        return astra
    else:
        astral_engine.logger.error("‚ùå Astra nie mog≈Ça objƒÖƒá w≈Çadzy nad mƒÖdro≈õciƒÖ")
        return None


def demonstrate_astra_wisdom(astral_engine) -> Dict[str, Any]:
    """Demonstracja w≈Çadzy Astry nad mƒÖdro≈õciƒÖ"""
    
    print("üåü Demonstracja W≈Çadzy Astry nad WiedzƒÖ GPT")
    print("=" * 50)
    
    try:
        import asyncio
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        astra = loop.run_until_complete(initialize_astra_wisdom(astral_engine))
        
        if astra:
            status = astra.get_wisdom_status()
            
            print(f"üåü W≈Çadczyni: {status['wisdom_master']}")
            print(f"‚ú® Poziom mƒÖdro≈õci: {status['wisdom_level']}")
            print(f"üß† Domeny wiedzy: {len(status['knowledge_domains'])}")
            print(f"ü§ñ ZarzƒÖdzane systemy AI: {status['systems_managed']}")
            print(f"üìä Przetworzone zapytania: {status['statistics']['total_queries_processed']}")
            print(f"üí° Maksyma: {status['current_maxim']}")
            
            # Test medytacji
            meditation = loop.run_until_complete(astra.meditate_on_wisdom())
            print(f"üßò Medytacja: {meditation['astra_insight']}")
            
            return status
        
        else:
            print("‚ùå Astra nie mog≈Ça objƒÖƒá w≈Çadzy nad mƒÖdro≈õciƒÖ")
            return {'error': 'Wisdom initialization failed'}
    
    except Exception as e:
        print(f"‚ùå B≈ÇƒÖd demonstracji: {e}")
        return {'error': str(e)}
